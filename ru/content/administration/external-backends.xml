<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">


<section id="external-backends">
<title>Using External backends</title>

<section id='customer-data'>
<title>Customer Data</title>

<para>
OTRS работает с различными атрибутами данных клиентов, такими как имя
пользователя, адрес электронной почты, номер телефона и т.д. Эти атрибуты
отображаются в обеих фронтэндах, для Агентов и Клиентов. Они также
используются для проверки подлинности клиентов.
</para>

<para>
Данные клиентов, которые используются и отображаются в OTRS очень легко
настраиваются. Несмотря на это следующая информация будет всегда необходима
для проверки подлинности клиента:
</para>

<para>
<itemizedlist>
  <listitem>
    <para>
      Вход пользователей
    </para>
  </listitem>
  <listitem>
    <para>
      Адресс электронной почты
    </para>
  </listitem>
  <listitem>
    <para>
      ID Клиента
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Используйте следующие параметры SysConfig, если желаете отобразить
информацию о клиенте в интерфейсе агента.
</para>

<para>
<programlisting>
    # Ticket::Frontend::CustomerInfo*
    # (show customer info on Compose (Phone and Email), Zoom and
    # Queue view)
    $Self->{'Ticket::Frontend::CustomerInfoCompose'} = 1;
    $Self->{'Ticket::Frontend::CustomerInfoZoom'} = 1;
</programlisting>
</para>

<para>
<emphasis>Скрипт: Параметры конфигурации SysConfig.</emphasis>
</para>

</section>

<section id="customer-user-backend">
<title>Customer User Backend</title>

<para>
Вы можете использоваь два типа хранилища информации клиентов: Базу Данных DB
и LDAP. Если у вас уже есть другой бэк-енд для хранения пользовательской
информации (например SAP), также есть возможность написать модуль для
использования этой функции.
</para>

<section id='customer-backend-db'>
<title>База Данных (По умолчанию)</title>

<para>
The Example below shows the configuration of a DB customer backend, which
uses customer data stored in the OTRS database.
</para>

<example id='db-customer-backend'>
<title>Настройка клиентского хранилища базы данных (DB)</title>

<para>
<programlisting>
# CustomerUser (customer database backend and settings)
$Self->{CustomerUser} = {
    Name => 'Database Datasource',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the required settings
#            DSN => 'DBI:odbc:yourdsn',
#            Type => 'mssql', # only for ODBC connections
#            DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#            User => '',
#            Password => '',
            Table => 'customer_user',

            # CaseSensitive will control if the SQL statements need LOWER()
            #   function calls to work case insensitively. Setting this to
            #   1 will improve performance dramatically on large databases.
            CaseSensitive => 0,
        },
# customer unique id
CustomerKey => 'login',

# customer #
CustomerID => 'customer_id',
CustomerValid => 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title','first_name','last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [
        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',      1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name', 1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',  1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',      1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',         0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',      1, 1, 'var', '', 0 ],

#        [ 'UserEmail',      'Email', 'email',           1, 1, 'var', '$Env{"CGIHandle"}?Action=AgentTicketCompose&amp;ResponseID=1&amp;TicketID=$Data{"TicketID"}&amp;ArticleID=$Data{"ArticleID"}', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id', 0, 1, 'var', '', 0 ],

#        [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',        'Phone',       'phone',        1, 0, 'var', '', 0 ],
        [ 'UserFax',          'Fax',         'fax',          1, 0, 'var', '', 0 ],
        [ 'UserMobile',       'Mobile',      'mobile',       1, 0, 'var', '', 0 ],
        [ 'UserStreet',       'Street',      'street',       1, 0, 'var', '', 0 ],
        [ 'UserZip',          'Zip',         'zip',          1, 0, 'var', '', 0 ],
        [ 'UserCity',         'City',        'city',         1, 0, 'var', '', 0 ],
        [ 'UserCountry',      'Country',     'country',      1, 0, 'var', '', 0 ],
        [ 'UserComment',      'Comment',     'comments',     1, 0, 'var', '', 0 ],
        [ 'ValidID',          'Valid',       'valid_id',     0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};
</programlisting>
</para>

</example>

<para>
Если нужно настроить данные клиентов, измените заголовки столбцов или
добавьте новые к таблице customer_user базы данных OTRS. В качестве примера
используйте нижеприведенный сценарий, в котором показано как добавить новое
поле для номера комнаты.
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 116 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD room VARCHAR (250);
Query OK, 1 rows affected (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
<emphasis>Сценарий: Добавление поля "комната" в таблицу customer_user
table. </emphasis>
</para>

<para>
Теперь добавьте новый столбец в MAP-масив в
<filename>Kernel/Config.pm</filename>, как это показано в нижеприведенном
сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserRoom',      'Room',      'room',       0, 1, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление поля "комната" в файл Kernel/Config.pm
file.</emphasis>
</para>

<para>
Всю эту информацию о клиенте можно также отредактировать воспользовавшись
ссылкой Клиенты в интерфейсе агента.
</para>

<section id='multi-customer-ids-db'>
<title>Customer with Multiple IDs (Company Tickets)</title>

<para>
Одному клиенту можно назначить больше одного клиентского идентификатора
(Customer ID). Это может быть полезно, если клиенту необходимо получить
доступ к заявкам других  клиентов, например, руководитель хочет посмотреть
заявки своих помощников. Если клиент может получить доступ к заявкам другого
клиента, то используется особенность OTRS "заявки компании". Заявки компании
могут быть доступны перейдя по ссылке "Заявки Компании" в клиентской панели
управления.
</para>

<para>
Для использованя заявок компании, новый столбец с идентификатором (IDs),
который должен быть доступен для клиента, должен быть добавлен в таблицу
customer_user базы данных OTRS (см. Сценарий ниже).
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 124 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD customer_ids VARCHAR (250);
Query OK, 1 rows affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
    <emphasis>Сценарий: Добавление поля customer_ids в таблицу
customer_user.</emphasis>
</para>

<para>
Теперь новый столбец должен быть добавлен в MAP-массив в
<filename>Kernel/Config.pm</filename>, как это показано в нижеприведенном
Сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление поля UserCustomerIDs в
Kernel/Config.pm</emphasis>
</para>

<para>
Теперь, новый столбец для мульти-идентификатора ( IDs) клиента можно
редактировать с помощью веб-интерфейса Агента, в разделе управления
клиентами.
</para>

<para>
To ensure that one customer can access the tickets of other customers, add
the IDs of these other users into the new field for the multiple customer
IDs. Each ID has to be separated by a semicolon (see Example below).
</para>

<example id='company-tickets-db'>
<title>Using Company Tickets with a DB Backend</title>

<para>
Клиенты А, Б и Ц созданы в вашей системе и А хочет иметь доступ к заявкам Б
и Ц используя клиентскую панель. Б и Ц не должны иметь доступа к заявкам
других пользователей.
</para>

<para>
Для реализации этой структуры, измените таблицу customer_user и маппинг
(преобразование) в <filename>Kernel/Config.pm</filename> как это показано
выше. С помощью Панели Администрирования или используя ссылку Клиенты в
веб-интерфейсе Агента загрузите настройки пользователя А. Если настройки
отображаются, добавьте значения "Б;Ц;" в поле для CustomerIDs.
</para>

</example>

</section>

</section>

<section id='customer-backend-ldap'>
<title>LDAP</title>

<para>
If you have an LDAP directory with your customer data, you can use it as the
customer backend with OTRS, as shown in Example below.
</para>

<example id='ldap-customer-backend'>
<title>Настройка LDAP в качестве клиентского бэк-енда</title>

<para>
<programlisting>
# CustomerUser
# (customer ldap backend and settings)
$Self->{CustomerUser} = {
    Name => 'LDAP Data Source',
    Module => 'Kernel::System::CustomerUser::LDAP',
    Params => {
        # ldap host
        Host => 'bay.csuhayward.edu',
        # ldap base dn
        BaseDN => 'ou=seas,o=csuh',
        # search scope (one|sub)
        SSCOPE => 'sub',
        # The following is valid but would only be necessary if the
        # anonymous user does NOT have permission to read from the LDAP tree
        UserDN => '',
        UserPw => '',
        # in case you want to add always one filter to each ldap query, use
        # this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
        AlwaysFilter => '',
            # if the charset of your ldap server is iso-8859-1, use this:
#            SourceCharset => 'iso-8859-1',

            # Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
            Params => {
                port => 389,
                timeout => 120,
                async => 0,
                version => 3,
            },
    },
    # customer unique id
    CustomerKey => 'uid',
    # customer #
    CustomerID => 'mail',
    CustomerUserListFields => ['cn', 'mail'],
    CustomerUserSearchFields => ['uid', 'cn', 'mail'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['mail'],
    CustomerUserNameFields => ['givenname', 'sn'],
    # show not own tickets in customer panel, CompanyTickets
    CustomerUserExcludePrimaryCustomerID => 0,
    # add an ldap filter for valid users (expert setting)
#    CustomerUserValidFilter => '(!(description=locked))',
    # administrator can't change customer preferences
    AdminSetPreferences => 0,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
    Map => [
        # note: Login, Email and CustomerID are mandatory!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
        [ 'UserTitle',      'Title',      'title',           1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'givenname',       1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'sn',              1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'uid',             1, 1, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'mail',            1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'mail',            0, 1, 'var', '', 0 ],
#        [ 'UserCustomerIDs', 'CustomerIDs', 'second_customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
        [ 'UserAddress',    'Address',    'postaladdress',   1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'description',     1, 0, 'var', '', 0 ],
    ],
};
</programlisting>
</para>

</example>

<para>
Если дополнительные атрибуты клиента хранятся в LDAP-каталоге, например, имя
руководителя, номер мобильного телефона, или отдела, и если эту информацию
нужно отобразить в OTRS, просто расширьте MAP-массив в файле
<filename>Kernel/Config.pm</filename> записями для этих атрибутов, как
показано в нижеприведенном сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Добавление нового поля в файл
Kernel/Config.pm.</emphasis>
</para>


<section id='multi-customer-ids-ldap'>
<title>Customer with Multiple IDs (Company Tickets)</title>

<para>
При использовании LDAP-бэкэнда клиенту можно присвоить больше одного
клиентского айди (Customer ID). Для использования заявок компании, в
LDAP-директорию нужно добавить новое поле, которое содержит доступные агенту
идентификаторы (IDs).
</para>

<para>
Если в LDAP-каталоге было созадно новое поле, его также нужно добавить в
MAP-массив в <filename>Kernel/Config.pm</filename>, как это показано в
нижеприведенном сценарии.
</para>

<para>
<programlisting>
    # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
    [...]
    [ 'UserCustomerIDs', 'CustomerIDs', 'customer_ids', 1, 0, 'var', '', 0 ],
</programlisting>
</para>

<para>
<emphasis>Сценарий: Подстановка новых полей в Kernel/Config.pm
file.</emphasis>
</para>

<para>
Клиентские идентификаторы (IDs) можно редактировать напрямую в
LDAP-директории. OTRS может только считать информацию из LDAP, но не
записывать.
</para>

<para>
To ensure access by a customer to the tickets of other customers, add the
customer IDs of the customers whose tickets should be accessed to the new
field in your LDAP directory. Each ID has to be separated by a semicolon
(see Example below).
</para>

<example id='company-tickets-ldap'>
<title>Использование заявок Компании с LDAP-бэкэндом</title>

<para>
Клиенты А, Б и Ц созданы в вашей системе и А хочет иметь доступ к заявкам Б
и Ц используя клиентскую панель. Б и Ц не должны иметь доступа к заявкам
других пользователей.
</para>

<para>
Для реализации этой установки измените LDAP-директорию и маппинг (mapping) в
<filename>Kernel/Config.pm</filename>, как это показано выше. Затем добавьте
в вашей LDAP-директории значения "Б;Ц;" в поле для CustomerIDs, для клиента
"А".
</para>

</example>

</section>

</section>

<section id='multiple-customer-backends'>
<title>Using More than One Customer Backend with OTRS</title>

<para>
If you want to utilize more than one customer data source used with OTRS
(e.g. an LDAP and a database backend), the CustomerUser config parameter
should be expanded with a number, e.g. "CustomerUser1", "CustomerUser2" (see
Example below).
</para>

<example id='multiple-customer-backend-example'>
<title>Использование больше чем одного пользовательского хранилища данных с OTRS</title>

<para>
В следующем примере показано применение конфигурации как для LDAP так и для
базы данных клиентского бэкэнда с OTRS.
</para>

<para>
<programlisting>
# 1. Customer user backend: DB
# (customer database backend and settings)
$Self->{CustomerUser1} = {
    Name => 'Customer Database',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the
        # required settings
#        DSN => 'DBI:odbc:yourdsn',
#        Type => 'mssql', # only for ODBC connections
#        DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#        User => '',
#        Password => '',
        Table => 'customer_user',
    },
    # customer unique id
    CustomerKey => 'login',
    # customer #
    CustomerID => 'customer_id',
    CustomerValid => 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title','first_name','last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache any database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [

        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',        1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name',   1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',    1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',        1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',           0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',        1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id',  0, 1, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'phone',        1, 0, 'var', '', 0 ],
        [ 'UserFax',        'Fax',        'fax',          1, 0, 'var', '', 0 ],
        [ 'UserMobile',     'Mobile',     'mobile',       1, 0, 'var', '', 0 ],
        [ 'UserStreet',     'Street',     'street',       1, 0, 'var', '', 0 ],
        [ 'UserZip',        'Zip',        'zip',          1, 0, 'var', '', 0 ],
        [ 'UserCity',       'City',       'city',         1, 0, 'var', '', 0 ],
        [ 'UserCountry',    'Country',    'country',      1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'comments',     1, 0, 'var', '', 0 ],
        [ 'ValidID',        'Valid',      'valid_id',     0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};

# 2. Customer user backend: LDAP
# (customer ldap backend and settings)
$Self->{CustomerUser2} = {
    Name => 'LDAP Datasource',
    Module => 'Kernel::System::CustomerUser::LDAP',
    Params => {
        # ldap host
        Host => 'bay.csuhayward.edu',
        # ldap base dn
        BaseDN => 'ou=seas,o=csuh',
        # search scope (one|sub)
        SSCOPE => 'sub',
        # The following is valid but would only be necessary if the
        # anonymous user does NOT have permission to read from the LDAP tree
        UserDN => '',
        UserPw => '',
        # in case you want to add always one filter to each ldap query, use
        # this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
        AlwaysFilter => '',
        # if the charset of your ldap server is iso-8859-1, use this:
#        SourceCharset => 'iso-8859-1',

        # Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
        Params => {
            port => 389,
            timeout => 120,
            async => 0,
            version => 3,
        },
    },
    # customer unique id
    CustomerKey => 'uid',
    # customer #
    CustomerID => 'mail',
    CustomerUserListFields => ['cn', 'mail'],
    CustomerUserSearchFields => ['uid', 'cn', 'mail'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['mail'],
    CustomerUserNameFields => ['givenname', 'sn'],
    # show not own tickets in customer panel, CompanyTickets
    CustomerUserExcludePrimaryCustomerID => 0,
    # add a ldap filter for valid users (expert setting)
#    CustomerUserValidFilter => '(!(description=locked))',
    # admin can't change customer preferences
    AdminSetPreferences => 0,
    Map => [
        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly
        [ 'UserTitle',      'Title',      'title',           1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'givenname',       1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'sn',              1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'uid',             1, 1, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'mail',            1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'mail',            0, 1, 'var', '', 0 ],
#        [ 'UserCustomerIDs', 'CustomerIDs', 'second_customer_ids', 1, 0, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'telephonenumber', 1, 0, 'var', '', 0 ],
        [ 'UserAddress',    'Address',    'postaladdress',   1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'description',     1, 0, 'var', '', 0 ],
    ],
};
</programlisting>
</para>

</example>

<para>
Есть возможность интегрировать до 10 различных пользовательских
бэк-эндов. Используйте интерфейс управления клиентами в OTRS, чтобы
просматривать и редактировать данные о них (при условии наличия прав для
записи).
</para>

</section>

<section id="dynamicfield-from-customeruser">
    <title>Storing CustomerUser Data in Dynamic Fields</title>
    <para>
        Иногда бывает полезным также сохранить данные клиента заявки непосредственно
в динамических полях заявки, для создания некоторых отчетов по этим
данным. Например, по заявкам компании, когда клиент в течение отчетного
периода перешел в другую компанию того же провайдера услуг техподдержки.
    </para>
    <para>
        Динамические поля заполняются при создании заявки или когда клиент заявки
изменяется. Значения полей берутся из данных клиента. Это работает для всех
бэкендов, но наиболее полезно для LDAP-бэкендов.
    </para>
    <para>
        Для включения этой опции OTRS, активируйте параметр
"Ticket::EventModulePost###930-DynamicFieldFromCustomerUser" и
"DynamicFieldFromCustomerUser::Mapping". Последний параметр содержит
настройку, какие поля данных клиента должны сохраняться в каждом из
динамических полей. Поля должны быть заранее созданы в системе и включены в
AgentTicketFreeText, так чтобы они были доступны для ручного заполнения. Они
должны быть недоступны для ввода в AgentTicketPhone, AgentTicketEmail и
AgentTicketCustomer, во избежание перекрытия автоматическии установленных
значений.
    </para>
</section>

</section>

<section id="auth-backends">
<title>Backends to Authenticate Agents and Customers</title>

<para>
OTRS предлагает опцию для проверки подлинности агентов и клиентов с
использованием различных хранилищ данных (бэкендов).
</para>

<section id='agent-auth-backends'>
<title>Хранилища данных (бэк-енды) для аутентификации Агентов</title>

<section id='agent-auth-backend-db'>
<title>База Данных (DB, по умаолчанию)</title>

<para>
The backend to authenticate agents which is used by default is the OTRS
database. Agents can be added and edited via the <link
linkend="adminarea-agents">agent management interface</link> in the <link
linkend="adminarea">Admin page</link> (see Example below).
</para>

<example id='configuration-agent-auth-backend-db'>
<title>Проверка подлинности агентов путем использования Базы Данных (DB) в качестве
хранилища информации.</title>

<para>
<programlisting>
    $Self->{'AuthModule'} = 'Kernel::System::Auth::DB';
</programlisting>
</para>

</example>

</section>

<section id='agent-auth-backend-ldap'>
<title>LDAP</title>

<para>
If an LDAP directory has all your agent data stored, you can use the LDAP
module to authenticate your users in OTRS (see Example below). This module
has only read access to the LDAP tree, which means that you cannot edit your
user data via the <link linkend='adminarea-agents'>agent management
interface</link>.
</para>

<example id='configuration-agent-auth-backend-ldap'>
<title>Проверка подлинности агентов при использовании LDAP в качестве хранилища
данных</title>

<para>
<programlisting>
# This is an example configuration for an LDAP auth. backend.
# (Make sure Net::LDAP is installed!)
$Self->{'AuthModule'} = 'Kernel::System::Auth::LDAP';
$Self->{'AuthModule::LDAP::Host'} = 'ldap.example.com';
$Self->{'AuthModule::LDAP::BaseDN'} = 'dc=example,dc=com';
$Self->{'AuthModule::LDAP::UID'} = 'uid';

# Check if the user is allowed to auth in a posixGroup
# (e. g. user needs to be in a group xyz to use otrs)
$Self->{'AuthModule::LDAP::GroupDN'} = 'cn=otrsallow,ou=posixGroups,dc=example,dc=com';
$Self->{'AuthModule::LDAP::AccessAttr'} = 'memberUid';
# for ldap posixGroups objectclass (just uid)
#  $Self->{'AuthModule::LDAP::UserAttr'} = 'UID';
# for non ldap posixGroups objectclass (with full user dn)
#  $Self->{'AuthModule::LDAP::UserAttr'} = 'DN';

# The following is valid but would only be necessary if the
# anonymous user do NOT have permission to read from the LDAP tree
$Self->{'AuthModule::LDAP::SearchUserDN'} = '';
$Self->{'AuthModule::LDAP::SearchUserPw'} = '';

# in case you want to add always one filter to each ldap query, use
# this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
$Self->{'AuthModule::LDAP::AlwaysFilter'} = '';

# in case you want to add a suffix to each login name, then
# you can use this option. e. g. user just want to use user but
# in your ldap directory exists user@domain.com
#    $Self->{'AuthModule::LDAP::UserSuffix'} = '@domain.com';

# Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
$Self->{'AuthModule::LDAP::Params'} = {
    port => 389,
    timeout => 120,
    async => 0,
    version => 3,
};
</programlisting>
</para>

</example>

<para>
Параметры конфигурации приведенные в сценарии приведенном ниже могут быть
использованы для синхронизации пользовательских данных из LDAP-каталога в
локальную базу данных OTRS. Это уменьшает количество запросов к LDAP-серверу
и ускоряет проверку подлинности в OTRS. Синхронизация данных завершена,
когда агент аутентифицируется впервые. Несмотря на то, что данные могут быть
синхронизированны в локальной базе данных OTRS, LDAP-каталог является
последней инстанцией для проверки подлинности пользователей, таким образом
пользователи, не активные для дерева каталогов LDAP не могут пройти
аутентификацию в OTRS, даже в том случае, когда данные о пользователе уже
хранятся в базе данных OTRS. Данные агентов в LDAP-директории не могут быть
отредактированы с помощью веб-интерфейса OTRS, так что управление данными
должно осуществлятся непосредственно в дереве каталогов LDAP.
</para>

<para>
<programlisting>
# defines AuthSyncBackend (AuthSyncModule) for AuthModule
# if this key exists and is empty, there won't be a sync.
# example values: AuthSyncBackend, AuthSyncBackend2
$Self->{'AuthModule::UseSyncBackend'} = 'AuthSyncBackend';

# agent data sync against ldap
$Self->{'AuthSyncModule'} = 'Kernel::System::Auth::Sync::LDAP';
$Self->{'AuthSyncModule::LDAP::Host'} = 'ldap://ldap.example.com/';
$Self->{'AuthSyncModule::LDAP::BaseDN'} = 'dc=otrs, dc=org';
$Self->{'AuthSyncModule::LDAP::UID'} = 'uid';
$Self->{'AuthSyncModule::LDAP::SearchUserDN'} = 'uid=sys, ou=user, dc=otrs, dc=org';
$Self->{'AuthSyncModule::LDAP::SearchUserPw'} = 'some_pass';
$Self->{'AuthSyncModule::LDAP::UserSyncMap'} = {
    # DB -> LDAP
    UserFirstname => 'givenName',
    UserLastname  => 'sn',
    UserEmail     => 'mail',
};
[...]

# AuthSyncModule::LDAP::UserSyncInitialGroups
# (sync following group with rw permission after initial create of first agent
# login)
$Self->{'AuthSyncModule::LDAP::UserSyncInitialGroups'} = [
    'users',
];
</programlisting>
</para>

<para>
<emphasis>Сценарий: Синхронизация пользовательских данных из
LDAP-директориив базу данных OTRS.</emphasis>
</para>

<para>
    Alternatively, you can use LDAP groups to determine group memberships or
roles in OTRS. For more information and examples, see
<filename>Kernel/Config/Defaults.pm</filename>. Here is an example for
synchronizing from LDAP into OTRS groups.
</para>

<para>
    <programlisting>
# Attributes needed for group syncs
# (attribute name for group value key)
$Self->{'AuthSyncModule::LDAP::AccessAttr'} = 'memberUid';
# (select the attribute for type of group content UID/DN for full ldap name)
# $Self->{'AuthSyncModule::LDAP::UserAttr'} = 'UID';
# $Self->{'AuthSyncModule::LDAP::UserAttr'} = 'DN';

AuthSyncModule::LDAP::UserSyncGroupsDefinition
# (If "LDAP" was selected for AuthModule and you want to sync LDAP
# groups to otrs groups, define the following.)
$Self->{'AuthSyncModule::LDAP::UserSyncGroupsDefinition'} = {
    # your ldap group
    'cn=agent,o=otrs' => {
        # otrs group(s)
        'admin' => {
            # permission
            rw => 1,
            ro => 1,
        },
        'faq' => {
            rw => 0,
            ro => 1,
        },
    },
    'cn=agent2,o=otrs' => {
        'users' => {
            rw => 1,
            ro => 1,
        },
    }
};
    </programlisting>
</para>

</section>

<section id='agent-auth-backend-httpbasic'>
<title>HTTPBasicAuth-аутентификация для Агентов</title>

<para>
If you want to implement a "single sign on" solution for all your agents,
you can use HTTP basic authentication (for all your systems) and the
HTTPBasicAuth module for OTRS (see Example below).
</para>

<example id='configuration-agent-auth-backend-htbasic'>
<title>Аутентификация Агентов с помощью HTTPBasic</title>

<para>
<programlisting>
# This is an example configuration for an apache ($ENV{REMOTE_USER})
# auth. backend. Use it if you want to have a singe login through
# apache http-basic-auth
$Self->{'AuthModule'} = 'Kernel::System::Auth::HTTPBasicAuth';

# Note:
#
# If you use this module, you should use as fallback
# the following configuration settings if the user is not authorized
# apache ($ENV{REMOTE_USER})
$Self->{LoginURL} = 'http://host.example.com/not-authorised-for-otrs.html';
$Self->{LogoutURL} = 'http://host.example.com/thanks-for-using-otrs.html';
</programlisting>
</para>

</example>

</section>

<section id='agent-auth-backend-radius'>
<title>Radius</title>

<para>
The configuration parameters shown in Example below can be used to
authenticate agents against a Radius server.
</para>

<example id='configuration-agent-auth-backend-radius'>
<title>Аутентификация (проверка подлинности) агентов с использованием
Radius-сервера в качестве хранилища информации</title>

<para>
<programlisting>
# This is example configuration to auth. agents against a radius server
$Self->{'AuthModule'} = 'Kernel::System::Auth::Radius';
$Self->{'AuthModule::Radius::Host'} = 'radiushost';
$Self->{'AuthModule::Radius::Password'} = 'radiussecret';
</programlisting>
</para>

</example>

</section>

</section>

<section id="customer-auth-backends">
<title>Authentication Backends for Customers</title>

<section id='customer-auth-backend-db'>
<title>База Данных (По умолчанию)</title>

<para>
The default user authentication backend for customers in OTRS is the OTRS
database. With this backend, all customer data can be edited via the web
interface of OTRS (see Example below).
</para>

<example id='configuration-customer-auth-backend-db'>
<title>Аутентификация Клиента в Базе Данных</title>

<para>
<programlisting>
# This is the auth. module against the otrs db
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::DB';
$Self->{'Customer::AuthModule::DB::Table'} = 'customer_user';
$Self->{'Customer::AuthModule::DB::CustomerKey'} = 'login';
$Self->{'Customer::AuthModule::DB::CustomerPassword'} = 'pw';
#$Self->{'Customer::AuthModule::DB::DSN'} = "DBI:mysql:database=customerdb;host=customerdbhost";
#$Self->{'Customer::AuthModule::DB::User'} = "some_user";
#$Self->{'Customer::AuthModule::DB::Password'} = "some_password";
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-ldap'>
<title>LDAP</title>

<para>
If you have an LDAP directory with all your customer data, you can use the
LDAP module to authenticate your customers to OTRS (see Example
below). Because this module has only read-access to the LDAP backend, it is
not possible to edit the customer data via the OTRS web interface.
</para>

<example id='configuration-customer-auth-backend-ldap'>
<title>Аутентификация пользователей с помощью LDAP-бэкэнда</title>

<para>
<programlisting>
# This is an example configuration for an LDAP auth. backend.
# (make sure Net::LDAP is installed!)
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::LDAP';
$Self->{'Customer::AuthModule::LDAP::Host'} = 'ldap.example.com';
$Self->{'Customer::AuthModule::LDAP::BaseDN'} = 'dc=example,dc=com';
$Self->{'Customer::AuthModule::LDAP::UID'} = 'uid';

# Check if the user is allowed to auth in a posixGroup
# (e. g. user needs to be in a group xyz to use otrs)
$Self->{'Customer::AuthModule::LDAP::GroupDN'} = 'cn=otrsallow,ou=posixGroups,dc=example,dc=com';
$Self->{'Customer::AuthModule::LDAP::AccessAttr'} = 'memberUid';
# for ldap posixGroups objectclass (just uid)
$Self->{'Customer::AuthModule::LDAP::UserAttr'} = 'UID';
# for non ldap posixGroups objectclass (full user dn)
#$Self->{'Customer::AuthModule::LDAP::UserAttr'} = 'DN';

# The following is valid but would only be necessary if the
# anonymous user does NOT have permission to read from the LDAP tree
$Self->{'Customer::AuthModule::LDAP::SearchUserDN'} = '';
$Self->{'Customer::AuthModule::LDAP::SearchUserPw'} = '';

# in case you want to add always one filter to each ldap query, use
# this option. e. g. AlwaysFilter => '(mail=*)' or AlwaysFilter => '(objectclass=user)'
$Self->{'Customer::AuthModule::LDAP::AlwaysFilter'} = '';

# in case you want to add a suffix to each customer login name, then
# you can use this option. e. g. user just want to use user but
# in your ldap directory exists user@domain.com
#$Self->{'Customer::AuthModule::LDAP::UserSuffix'} = '@domain.com';

# Net::LDAP new params (if needed - for more info see perldoc Net::LDAP)
$Self->{'Customer::AuthModule::LDAP::Params'} = {
    port => 389,
    timeout => 120,
    async => 0,
    version => 3,
};
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-httpbasic'>
<title>HTTPBasicAuth for Customers</title>

<para>
If you want to implement a "single sign on" solution for all your customer
users, you can use HTTPBasic authentication (for all your systems) and use
the HTTPBasicAuth module with OTRS (no login is needed with OTRS any
more). See Example below.
</para>

<example id='configuration-customer-auth-backend-htbasic'>
<title>Аутентификация клиентов с помощью HTTPBasic</title>

<para>
<programlisting>
# This is an example configuration for an apache ($ENV{REMOTE_USER})
# auth. backend. Use it if you want to have a singe login through
# apache http-basic-auth
$Self->{'Customer::AuthModule'} = 'Kernel::System::CustomerAuth::HTTPBasicAuth';

# Note:
# If you use this module, you should use the following
# config settings as fallback, if user isn't login through
# apache ($ENV{REMOTE_USER})
$Self->{CustomerPanelLoginURL} = 'http://host.example.com/not-authorised-for-otrs.html';
$Self->{CustomerPanelLogoutURL} = 'http://host.example.com/thanks-for-using-otrs.html';
</programlisting>
</para>

</example>

</section>

<section id='customer-auth-backend-radius'>
<title>Radius</title>

<para>
The settings shown in Example below can be used to authenticate your
customers against a Radius server.
</para>

<example id='configuration-customer-auth-backend-radius'>
<title>Аутентификация клиентов с использованием Radius</title>

<para>
<programlisting>
# This is a example configuration to auth. customer against a radius server
$Self->{'Customer::AuthModule'} = 'Kernel::System::Auth::Radius';
$Self->{'Customer::AuthModule::Radius::Host'} = 'radiushost';
$Self->{'Customer::AuthModule::Radius::Password'} = 'radiussecret';
</programlisting>
</para>

</example>

</section>

</section>

</section>

<section id="customer-self-registration">
<title>Customizing the Customer Self-Registration</title>

<para>
Есть возможность настроить самостоятельную регистрацию новых клиентов,
доступную через панель customer.pl. Можно добавить новые дополнительные или
обязательные поля, такие как номер комнаты, адрес или состояние.
</para>

<para>
В следующем примере показано каким образом можно указать обязательные для
заполнения поля в базе данных клиентов, в данном случае, для хранения номера
клиента.
</para>

<section id='customer-self-registration-dtl'>
<title>Customizing the Web Interface</title>

<para>
Для отображения нового поля для номера комнаты в веб-интерфейсе пользователя
(customer.pl), нужно внести изменения в .dtl-файл, который отвечает за
шаблон этого интерфейса. Отредактируйте файл
<filename>Kernel/Output/HTML/Standard/CustomerLogin.dtl</filename> добавив
новые поля после строки 80 (см. нижеприведенный сценарий).
</para>

<para>
<programlisting>
[...]
&lt;div class="NewLine"&gt;
    &lt;label for="Room"&gt;$Text{"Room{CustomerUser}"}&lt;/label&gt;
    &lt;input title="$Text{"Room Number"}" name="Room" type="text" id="UserRoom" maxlength="50" /&gt;
&lt;/div&gt;
[...]
</programlisting>
</para>

<para>
<emphasis>Сценарий: Отображение новых полей в веб-интерфейсе.</emphasis>
</para>

</section>

<section id="customer-self-registration-mapping">
<title>Customer Mapping</title>

<para>
На следующем этапе, нужно внести изменения в маппинг (mapping), рассширив
его новым элементом - номером комнаты. Чтобы убедится что изменения не
потеряются после обновления, установите настройкы "CustomerUser" из файла
<filename>Kernel/Config/Defaults.pm</filename> в файл
<filename>Kernel/Config.pm</filename>. Теперь измените MAP-массив, добавив
новое поле - номер комнаты, как это показано в нижеприведенном сценарии.
</para>

<para>
<programlisting>
# CustomerUser
# (customer database backend and settings)
$Self->{CustomerUser} = {
    Name => 'Database Backend',
    Module => 'Kernel::System::CustomerUser::DB',
    Params => {
        # if you want to use an external database, add the
        # required settings
#        DSN => 'DBI:odbc:yourdsn',
#        Type => 'mssql', # only for ODBC connections
#        DSN => 'DBI:mysql:database=customerdb;host=customerdbhost',
#        User => '',
#        Password => '',
        Table => 'customer_user',
    },
    # customer unique id
    CustomerKey => 'login',
    # customer #
    CustomerID => 'customer_id',
    CustomerValid => 'valid_id',
    CustomerUserListFields => ['first_name', 'last_name', 'email'],
#    CustomerUserListFields => ['login', 'first_name', 'last_name', 'customer_id', 'email'],
    CustomerUserSearchFields => ['login', 'last_name', 'customer_id'],
    CustomerUserSearchPrefix => '',
    CustomerUserSearchSuffix => '*',
    CustomerUserSearchListLimit => 250,
    CustomerUserPostMasterSearchFields => ['email'],
    CustomerUserNameFields => ['title', 'first_name', 'last_name'],
    CustomerUserEmailUniqCheck => 1,
#    # show not own tickets in customer panel, CompanyTickets
#    CustomerUserExcludePrimaryCustomerID => 0,
#    # generate auto logins
#    AutoLoginCreation => 0,
#    AutoLoginCreationPrefix => 'auto',
#    # admin can change customer preferences
#    AdminSetPreferences => 1,
#    # cache time to live in sec. - cache database queries
#    CacheTTL => 0,
#    # just a read only source
#    ReadOnly => 1,
    Map => [

        # note: Login, Email and CustomerID needed!
        # var, frontend, storage, shown (1=always,2=lite), required, storage-type, http-link, readonly, http-link-target
        [ 'UserTitle',      'Title',      'title',       1, 0, 'var', '', 0 ],
        [ 'UserFirstname',  'Firstname',  'first_name',  1, 1, 'var', '', 0 ],
        [ 'UserLastname',   'Lastname',   'last_name',   1, 1, 'var', '', 0 ],
        [ 'UserLogin',      'Username',   'login',       1, 1, 'var', '', 0 ],
        [ 'UserPassword',   'Password',   'pw',          0, 0, 'var', '', 0 ],
        [ 'UserEmail',      'Email',      'email',       1, 1, 'var', '', 0 ],
        [ 'UserCustomerID', 'CustomerID', 'customer_id', 0, 1, 'var', '', 0 ],
        [ 'UserPhone',      'Phone',      'phone',       1, 0, 'var', '', 0 ],
        [ 'UserFax',        'Fax',        'fax',         1, 0, 'var', '', 0 ],
        [ 'UserMobile',     'Mobile',     'mobile',      1, 0, 'var', '', 0 ],
        [ 'UserRoom',       'Room',       'room',        1, 0, 'var', '', 0 ],
        [ 'UserStreet',     'Street',     'street',      1, 0, 'var', '', 0 ],
        [ 'UserZip',        'Zip',        'zip',         1, 0, 'var', '', 0 ],
        [ 'UserCity',       'City',       'city',        1, 0, 'var', '', 0 ],
        [ 'UserCountry',    'Country',    'country',     1, 0, 'var', '', 0 ],
        [ 'UserComment',    'Comment',    'comments',    1, 0, 'var', '', 0 ],
        [ 'ValidID',        'Valid',      'valid_id',    0, 1, 'int', '', 0 ],
    ],
    # default selections
    Selections => {
        UserTitle => {
            'Mr.' => 'Mr.',
            'Mrs.' => 'Mrs.',
        },
    },
};
</programlisting>
</para>

<para>
<emphasis>Сценарий: Внесение изменений в map-массив.</emphasis>
</para>

</section>

<section id="customer-self-registration-customer-table">
<title>Customizing the <literal>customer_user</literal> Table in the OTRS DB</title>

<para>
Последним шагом является добавление нового столбца с номером комнаты в
таблицу customer_user базы данных OTRS (см. нижеприведенный сценарий). В
этой колонке будет хранится информация для номера комнаты.
</para>

<para>
<screen>
linux:~# mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 6 to server version: 5.0.18-Debian_7-log

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; use otrs;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; ALTER TABLE customer_user ADD room VARCHAR (200);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; quit
Bye
linux:~#
</screen>
</para>

<para>
<emphasis>Сценарий: Добавление новой колонки в таблицу
customer_user.</emphasis>
</para>

<para>
Now the new field for the room should be displayed in the Customer
Information panel if filled, and in the Customer User administration
screens. Also, new customers should have to insert their room number if they
register a new account.
</para>
</section>

</section>

</section>
